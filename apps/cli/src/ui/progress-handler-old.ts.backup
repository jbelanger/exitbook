import type { ProviderEvent } from '@exitbook/blockchain-providers';
import type { InstrumentationCollector } from '@exitbook/http';
import type { IngestionEvent } from '@exitbook/ingestion';
import { getLogger } from '@exitbook/logger';
import { logUpdateStderr } from 'log-update';
import pc from 'picocolors';

import { CLI_VERSION } from '../index.js';

import type { ProviderState } from './provider-state-aggregator.js';
import { ProviderStateAggregator } from './provider-state-aggregator.js';
import { VelocityTracker } from './velocity-tracker.js';

export type CliEvent = IngestionEvent | ProviderEvent;

const DASHBOARD_UPDATE_INTERVAL_MS = 250;

/**
 * Handles real-time progress display for CLI operations.
 * Subscribes to event bus and writes to stderr for live updates.
 */
export class ProgressHandler {
  private readonly logger = getLogger('ProgressHandler');
  private batchStats = {
    new: 0,
    skipped: 0,
    total: 0,
    fetchedRun: 0,
  };

  // Dashboard state
  private dashboardMode = false;
  private dashboardUpdateInterval: NodeJS.Timeout | undefined;
  private velocityTracker = new VelocityTracker();
  private providerStateAggregator = new ProviderStateAggregator();
  private instrumentation: InstrumentationCollector | undefined;
  private eventLog: EventLogEntry[] = []; // Persists across phases
  private importStartedAt: number | undefined;
  private currentPhase: 'import' | 'process' | 'complete' | undefined;

  // Processing phase state
  private processStartedAt: number | undefined;
  private processPendingCount = 0;
  private processBatchNumber = 0;
  private batchStartTimes: number[] = []; // Track last 5 batch start times for ETA
  private metadataStats = {
    cacheHits: 0,
    cacheMisses: 0,
  };
  private scamStats = {
    totalFound: 0,
    recentExamples: [] as string[], // Last 3 examples
  };

  // Completion stats (stored from events)
  private completionStats = {
    importDurationMs: 0,
    importTotalImported: 0,
    processDurationMs: 0,
    processTotalProcessed: 0,
  };

  // Cached metrics to avoid refiltering on every render
  private cachedMetrics:
    | {
        blockchainProviders: ProviderState[];
        metadataProviders: ProviderState[];
        timestamp: number;
        velocity: number;
      }
    | undefined;

  /**
   * Handle an event from the event bus.
   * Writes progress updates to stderr (keeps stdout clean for command output).
   */
  handleEvent(event: CliEvent): void {
    try {
      switch (event.type) {
        case 'import.started': {
          this.currentPhase = 'import';
          this.importStartedAt = Date.now();

          // Start dashboard update loop
          if (!this.dashboardUpdateInterval) {
            this.dashboardUpdateInterval = setInterval(() => {
              this.renderDashboard();
            }, DASHBOARD_UPDATE_INTERVAL_MS);
          }
          this.renderDashboard();
          break;
        }

        case 'import.session.created':
        case 'import.session.resumed':
          // Session events are logged but not displayed in dashboard
          break;

        case 'import.batch': {
          // Update stats
          this.batchStats.new += event.batchInserted;
          this.batchStats.skipped += event.batchSkipped;
          this.batchStats.total = event.totalImported;
          this.batchStats.fetchedRun = event.totalFetchedRun;

          // Add to event log if significant
          if (event.batchInserted > 0) {
            this.addToEventLog('â„¹', `Saved batch of ${event.batchInserted} transactions`);
          }
          break;
        }

        case 'import.warning':
          this.addToEventLog('âš ', `Warning: ${event.warning}`);
          break;

        case 'import.completed': {
          // Store completion stats for final summary
          this.completionStats.importDurationMs = event.durationMs;
          this.completionStats.importTotalImported = event.totalImported;

          // Keep dashboard running (processing phase will start next)
          // Dashboard will continue to show import stats until process.started
          break;
        }

        case 'import.failed':
          this.addToEventLog('âœ—', `Import failed: ${event.error}`);
          this.logToStderr(pc.red(`âœ— Import failed for ${event.sourceName}: ${event.error}`));
          break;

        case 'process.started':
          this.currentPhase = 'process';
          this.processStartedAt = Date.now();
          this.processPendingCount = event.totalRaw;
          this.processBatchNumber = 0;
          this.batchStartTimes = [];

          // Dashboard mode: rendering happens on interval
          this.renderDashboard();
          break;

        case 'process.batch': {
          // Event is tracked but not displayed directly (batch.started/completed provide better info)
          break;
        }

        case 'process.completed': {
          this.currentPhase = 'complete';

          // Store completion stats for final summary
          this.completionStats.processDurationMs = event.durationMs;
          this.completionStats.processTotalProcessed = event.totalProcessed;

          // Stop dashboard updates
          if (this.dashboardUpdateInterval) {
            clearInterval(this.dashboardUpdateInterval);
            this.dashboardUpdateInterval = undefined;
          }

          // Render final completion summary
          this.renderCompletionSummary();
          break;
        }

        case 'process.failed':
          this.addToEventLog('âœ—', `Processing failed: ${event.error}`);
          this.logToStderr(pc.red(`âœ— Processing failed: ${event.error}`));
          break;

        case 'process.skipped':
          this.addToEventLog('â„¹', `Skipped: ${event.reason}`);
          break;

        case 'process.batch.started':
          this.processBatchNumber = event.batchNumber;
          this.processPendingCount = event.pendingCount;

          // Track batch start time for ETA calculation (keep last 5)
          this.batchStartTimes.push(Date.now());
          if (this.batchStartTimes.length > 5) {
            this.batchStartTimes.shift();
          }
          break;

        case 'process.batch.completed':
          this.processPendingCount = event.pendingCount;
          break;

        case 'process.group.processing':
          // This event provides granular detail, could be used for event log
          // For now, just ignore (too noisy)
          break;

        case 'metadata.batch.completed':
          // Accumulate per-batch deltas
          this.metadataStats.cacheHits += event.cacheHits;
          this.metadataStats.cacheMisses += event.cacheMisses;
          break;

        case 'scam.batch.summary':
          // Accumulate per-batch counts
          this.scamStats.totalFound += event.scamsFound;

          // Track recent examples (last 3 unique)
          if (event.exampleSymbols.length > 0) {
            for (const symbol of event.exampleSymbols) {
              if (!this.scamStats.recentExamples.includes(symbol)) {
                this.scamStats.recentExamples.push(symbol);
                if (this.scamStats.recentExamples.length > 3) {
                  this.scamStats.recentExamples.shift();
                }
              }
            }
          }
          break;

        // Provider selection & switching
        case 'provider.selection':
          // Tracked but not displayed directly in dashboard
          break;

        case 'provider.resume':
          this.addToEventLog('â†»', `Resumed with ${event.provider}`);
          break;

        case 'provider.cursor.adjusted':
          // Tracked but not displayed directly
          break;

        case 'provider.failover':
          this.providerStateAggregator.trackEvent(event);
          this.addToEventLog('â‡„', `Switched to ${event.to}`);
          break;

        case 'provider.rate_limited': {
          this.providerStateAggregator.trackEvent(event);
          this.addToEventLog('âš ', `${event.provider}: Rate limited`);
          break;
        }

        case 'provider.circuit_open':
          this.providerStateAggregator.trackEvent(event);
          this.addToEventLog('ðŸ”´', `${event.provider}: Circuit breaker opened`);
          break;

        case 'provider.backoff':
          // Tracked but not displayed directly
          break;

        // Provider request events are too noisy for CLI - ignore them
        case 'provider.request.started':
        case 'provider.request.failed':
          // Silently ignore - these are for telemetry systems
          break;

        case 'provider.request.succeeded':
          // Track for provider state updates (clears rate limit / circuit state)
          this.providerStateAggregator.trackEvent(event);
          break;

        default: {
          // TypeScript exhaustiveness check - will error if we miss an event type
          const _exhaustive: never = event;
          this.logger.warn({ event: _exhaustive }, 'Unhandled event type');
        }
      }
    } catch (err) {
      // Never let event handler errors crash the system
      this.logger.warn({ err, event }, 'Error handling event');
    }
  }

  /**
   * Enable dashboard mode and set instrumentation collector.
   * Must be called before import/process starts to enable real-time dashboard.
   */
  setInstrumentation(instrumentation: InstrumentationCollector): void {
    this.instrumentation = instrumentation;
    this.dashboardMode = true;
  }

  /**
   * Stop dashboard updates and clean up.
   */
  destroy(): void {
    if (this.dashboardUpdateInterval) {
      clearInterval(this.dashboardUpdateInterval);
      this.dashboardUpdateInterval = undefined;
    }
    if (this.dashboardMode) {
      logUpdateStderr.done();
    }
  }

  /**
   * Write a line to stderr (keeps stdout clean for command output).
   */
  private logToStderr(message: string): void {
    process.stderr.write(`${message}\n`);
  }

  /**
   * Add event to the event log (footer section).
   * Keeps last 3 events only.
   */
  private addToEventLog(icon: string, message: string): void {
    this.eventLog.push({
      timestamp: Date.now(),
      icon,
      message,
    });

    // Keep only last 3 events
    if (this.eventLog.length > 3) {
      this.eventLog = this.eventLog.slice(-3);
    }
  }

  /**
   * Main dashboard render method.
   * Wrapped in try-catch to prevent render errors from crashing the system.
   */
  private renderDashboard(): void {
    try {
      // Update cached metrics before rendering
      this.updateCachedMetrics();

      let output = '';

      switch (this.currentPhase) {
        case 'import':
          output = this.renderImportDashboard();
          break;
        case 'process':
          output = this.renderProcessingDashboard();
          break;
        case 'complete':
          // Completion summary is rendered directly via renderCompletionSummary()
          // This case should not be reached since we stop the dashboard interval
          return;
        default:
          return;
      }

      logUpdateStderr(output);
    } catch (error) {
      this.logger.error({ error }, 'Dashboard render failed');
      // Fallback: clear dashboard and show error
      logUpdateStderr.clear();
      this.logger.warn('Dashboard rendering disabled due to error');
      if (this.dashboardUpdateInterval) {
        clearInterval(this.dashboardUpdateInterval);
        this.dashboardUpdateInterval = undefined;
      }
    }
  }

  /**
   * Render Phase 1/2 Import Dashboard.
   */
  private renderImportDashboard(): string {
    const sections: string[] = [];

    // HEADER
    sections.push('â”Œâ”€ HEADER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
    sections.push(`â”‚ EXITBOOK CLI  v${CLI_VERSION}  |  [â— PHASE 1/2: IMPORTING]           â”‚`);
    sections.push('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜');
    sections.push('');

    // BODY: Velocity & Safety
    sections.push('â”Œâ”€ BODY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
    sections.push('â”‚                                                             â”‚');
    sections.push('â”‚  [ VELOCITY ]                                               â”‚');
    sections.push(this.renderVelocitySection());
    sections.push('â”‚                                                             â”‚');

    // BODY: Provider Status
    sections.push('â”‚  [ PROVIDER STATUS ]                                        â”‚');
    sections.push(this.renderProviderStatusSection());
    sections.push('â”‚                                                             â”‚');

    // BODY: Import Progress
    sections.push('â”‚  [ IMPORT PROGRESS ]                                        â”‚');
    sections.push(this.renderImportProgressSection());
    sections.push('â”‚                                                             â”‚');
    sections.push('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜');
    sections.push('');

    // FOOTER: Event Log
    sections.push('â”Œâ”€ EVENTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
    sections.push(this.renderEventLogSection());
    sections.push('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜');

    return sections.join('\n');
  }

  /**
   * Render Phase 2/2 Processing Dashboard.
   */
  private renderProcessingDashboard(): string {
    const sections: string[] = [];

    // HEADER
    sections.push('â”Œâ”€ HEADER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
    sections.push(`â”‚ EXITBOOK CLI  v${CLI_VERSION}  |  [â— PHASE 2/2: PROCESSING]          â”‚`);
    sections.push('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜');
    sections.push('');

    // BODY: Pipeline Progress
    sections.push('â”Œâ”€ BODY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
    sections.push('â”‚                                                             â”‚');
    sections.push('â”‚  [ PIPELINE ]                                               â”‚');
    sections.push(this.renderPipelineSection());
    sections.push('â”‚                                                             â”‚');

    // BODY: Metadata Provider Status
    sections.push('â”‚  [ METADATA PROVIDERS ]                                     â”‚');
    sections.push(this.renderMetadataProviderSection());
    sections.push('â”‚                                                             â”‚');

    // BODY: Cache Stats
    sections.push('â”‚  [ CACHE STATS ]                                            â”‚');
    sections.push(this.renderCacheStatsSection());
    sections.push('â”‚                                                             â”‚');

    // BODY: Scam Detection
    sections.push('â”‚  [ SCAM DETECTION ]                                         â”‚');
    sections.push(this.renderScamDetectionSection());
    sections.push('â”‚                                                             â”‚');
    sections.push('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜');
    sections.push('');

    // FOOTER: Event Log (reused from Phase 1)
    sections.push('â”Œâ”€ EVENTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
    sections.push(this.renderEventLogSection());
    sections.push('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜');

    return sections.join('\n');
  }

  /**
   * Render pipeline section with batch progress and ETA.
   */
  private renderPipelineSection(): string {
    const pending = this.processPendingCount.toLocaleString();
    const batchNum = this.processBatchNumber;

    // Calculate ETA based on average batch time
    let etaStr = 'calculating...';
    if (this.batchStartTimes.length >= 2 && this.processPendingCount > 0) {
      // Calculate average time between batch starts
      const times = this.batchStartTimes;
      const intervals: number[] = [];
      for (let i = 1; i < times.length; i++) {
        intervals.push(times[i]! - times[i - 1]!);
      }
      const avgBatchTimeMs = intervals.reduce((a, b) => a + b, 0) / intervals.length;

      // Estimate remaining time (rough estimate based on pending count)
      // Assume similar batch sizes continue
      const estimatedRemainingMs = avgBatchTimeMs * Math.ceil(this.processPendingCount / 50); // Assume ~50 per batch
      etaStr = this.formatElapsedTime(estimatedRemainingMs);
    }

    const elapsed = this.processStartedAt ? this.formatElapsedTime(Date.now() - this.processStartedAt) : '00:00';

    const pendingLine = `â”‚  Pending:       ${pending.padEnd(47)} â”‚`;
    const batchLine = `â”‚  Batch:         #${String(batchNum).padEnd(46)} â”‚`;
    const elapsedLine = `â”‚  Time Elapsed:  ${elapsed.padEnd(47)} â”‚`;
    const etaLine = `â”‚  ETA:           ~${etaStr.padEnd(46)} â”‚`;

    return [pendingLine, batchLine, elapsedLine, etaLine].join('\n');
  }

  /**
   * Render metadata provider status section.
   */
  private renderMetadataProviderSection(): string {
    if (!this.cachedMetrics) {
      return 'â”‚  No instrumentation available                              â”‚';
    }

    const providers = this.cachedMetrics.metadataProviders;

    if (providers.length === 0) {
      return 'â”‚  No metadata providers active                               â”‚';
    }

    return this.renderProviderTable(providers);
  }

  /**
   * Render cache stats section.
   */
  private renderCacheStatsSection(): string {
    const { cacheHits, cacheMisses } = this.metadataStats;
    const total = cacheHits + cacheMisses;
    const hitRate = total > 0 ? ((cacheHits / total) * 100).toFixed(1) : '0.0';

    const hitsLine = `â”‚  Cache Hits:    ${cacheHits.toLocaleString().padEnd(47)} â”‚`;
    const missesLine = `â”‚  Cache Misses:  ${cacheMisses.toLocaleString().padEnd(47)} â”‚`;
    const rateLine = `â”‚  Hit Rate:      ${hitRate}%${' '.repeat(Math.max(0, 45 - hitRate.length))} â”‚`;

    return [hitsLine, missesLine, rateLine].join('\n');
  }

  /**
   * Render scam detection summary section.
   */
  private renderScamDetectionSection(): string {
    const totalFound = this.scamStats.totalFound.toLocaleString();
    const examples = this.scamStats.recentExamples.length > 0 ? this.scamStats.recentExamples.join(', ') : 'none';

    const totalLine = `â”‚  Total Found:   ${totalFound.padEnd(47)} â”‚`;
    const examplesLine = `â”‚  Examples:      ${examples.padEnd(47).substring(0, 47)} â”‚`;

    return [totalLine, examplesLine].join('\n');
  }

  /**
   * Render Phase 3: Completion Summary.
   * This is a static summary displayed after processing completes.
   */
  private renderCompletionSummary(): void {
    // Finalize live dashboard before rendering static summary
    logUpdateStderr.done();

    const sections: string[] = [];

    // HEADER
    sections.push('');
    sections.push('â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
    sections.push('â”‚                   IMPORT COMPLETE                           â”‚');
    sections.push('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜');
    sections.push('');

    // IMPORT STATS
    const importDuration = this.formatElapsedTime(this.completionStats.importDurationMs);
    const importCount = this.completionStats.importTotalImported.toLocaleString();
    sections.push('  IMPORT PHASE');
    sections.push(`    Transactions: ${pc.bold(importCount)}`);
    sections.push(`    Duration:     ${importDuration}`);
    sections.push('');

    // PROCESS STATS
    const processDuration = this.formatElapsedTime(this.completionStats.processDurationMs);
    const processCount = this.completionStats.processTotalProcessed.toLocaleString();
    sections.push('  PROCESSING PHASE');
    sections.push(`    Transactions: ${pc.bold(processCount)}`);
    sections.push(`    Duration:     ${processDuration}`);
    sections.push('');

    // METADATA STATS
    const { cacheHits, cacheMisses } = this.metadataStats;
    const totalMetadataRequests = cacheHits + cacheMisses;
    const hitRate = totalMetadataRequests > 0 ? ((cacheHits / totalMetadataRequests) * 100).toFixed(1) : '0.0';
    sections.push('  METADATA ENRICHMENT');
    sections.push(`    Cache Hits:   ${cacheHits.toLocaleString()}`);
    sections.push(`    Cache Misses: ${cacheMisses.toLocaleString()}`);
    sections.push(`    Hit Rate:     ${hitRate}%`);
    sections.push('');

    // SCAM DETECTION STATS
    sections.push('  SCAM DETECTION');
    sections.push(`    Total Found:  ${this.scamStats.totalFound.toLocaleString()}`);
    if (this.scamStats.recentExamples.length > 0) {
      sections.push(`    Examples:     ${this.scamStats.recentExamples.join(', ')}`);
    }
    sections.push('');

    // INSTRUMENTATION SUMMARY
    if (this.instrumentation) {
      const metrics = this.instrumentation.getMetrics();
      const totalRequests = metrics.length;

      sections.push('  API REQUESTS');
      sections.push(`    Total:        ${totalRequests.toLocaleString()}`);

      // Find provider with most requests
      if (metrics.length > 0) {
        const providerCounts = new Map<string, number>();
        for (const metric of metrics) {
          providerCounts.set(metric.provider, (providerCounts.get(metric.provider) ?? 0) + 1);
        }

        let topProvider = '';
        let maxCount = 0;
        for (const [provider, count] of providerCounts) {
          if (count > maxCount) {
            maxCount = count;
            topProvider = provider;
          }
        }

        sections.push(`    Top Provider: ${topProvider} (${maxCount.toLocaleString()} requests)`);
      }

      sections.push('');
    }

    // EVENT LOG (last 3 events from all phases)
    if (this.eventLog.length > 0) {
      sections.push('  RECENT EVENTS');
      for (const evt of this.eventLog) {
        const time = new Date(evt.timestamp).toLocaleTimeString();
        sections.push(`    ${time}  ${evt.icon}  ${evt.message}`);
      }
      sections.push('');
    }

    // Total duration
    const totalDurationMs = this.completionStats.importDurationMs + this.completionStats.processDurationMs;
    const totalDuration = this.formatElapsedTime(totalDurationMs);
    sections.push('â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
    sections.push(
      `â”‚  Total Duration: ${pc.bold(totalDuration)}${' '.repeat(Math.max(0, 43 - totalDuration.length))} â”‚`
    );
    sections.push('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜');
    sections.push('');

    // Write all sections to stderr
    this.logToStderr(sections.join('\n'));
  }

  /**
   * Update cached metrics. Call this before rendering to ensure fresh data.
   * Cache is valid for the duration of one render cycle (250ms).
   */
  private updateCachedMetrics(): void {
    if (!this.instrumentation) {
      this.cachedMetrics = undefined;
      return;
    }

    const metrics = this.instrumentation.getMetrics();
    const now = Date.now();

    // Update cache
    this.cachedMetrics = {
      timestamp: now,
      blockchainProviders: this.providerStateAggregator.getProviderRows(metrics, 'blockchain'),
      metadataProviders: this.providerStateAggregator.getProviderRows(metrics, 'metadata'),
      velocity: this.velocityTracker.getRequestsPerSecond(metrics),
    };
  }

  /**
   * Render velocity section with progress bar.
   */
  private renderVelocitySection(): string {
    if (!this.cachedMetrics) {
      return 'â”‚  VELOCITY: N/A (instrumentation disabled)                  â”‚';
    }

    const reqPerSecond = this.cachedMetrics.velocity;

    // Build progress bar (20 chars, fixed scale 0-100 req/s)
    const maxScale = 100;
    const barLength = 20;
    const filled = Math.min(Math.round((reqPerSecond / maxScale) * barLength), barLength);
    const bar = 'â”‚'.repeat(filled) + 'â–‘'.repeat(barLength - filled);

    // Add warning indicator if exceeding max scale
    const indicator = reqPerSecond > maxScale ? ' !' : '';
    const paddingLength = Math.max(0, 2 - indicator.length);
    const padding = ' '.repeat(paddingLength);

    const velocityValue = reqPerSecond.toFixed(0).padStart(3);
    return `â”‚  VELOCITY: ${velocityValue} req/s  [${bar}]${indicator}${padding} â”‚`;
  }

  /**
   * Render provider status table.
   */
  private renderProviderStatusSection(): string {
    if (!this.cachedMetrics) {
      return 'â”‚  No instrumentation available                              â”‚';
    }

    const providers = this.cachedMetrics.blockchainProviders;

    if (providers.length === 0) {
      return 'â”‚  No providers active                                        â”‚';
    }

    return this.renderProviderTable(providers);
  }

  /**
   * Render provider table with standard formatting.
   * Extracted for reuse in Phase 2 (metadata providers).
   */
  private renderProviderTable(providers: ProviderState[]): string {
    const lines: string[] = [];
    lines.push('â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚');
    lines.push('â”‚  â”‚ PROVIDER     â”‚ STATUS     â”‚ LATENCY â”‚ REQ/S   â”‚ THROTTLESâ”‚â”‚');
    lines.push('â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”‚');

    for (const provider of providers) {
      const name = provider.name.padEnd(12).substring(0, 12);
      const status = provider.statusDisplay.padEnd(10).substring(0, 10);
      const latency = `${provider.latencyMs}ms`.padEnd(7).substring(0, 7);
      const reqPerSec = `${provider.requestsPerSecond.toFixed(0)} req/s`.padEnd(7).substring(0, 7);
      const throttles = String(provider.throttleCount).padEnd(8).substring(0, 8);

      lines.push(`â”‚  â”‚ ${name} â”‚ ${status} â”‚ ${latency} â”‚ ${reqPerSec} â”‚ ${throttles}  â”‚â”‚`);
    }

    lines.push('â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚');

    return lines.join('\n');
  }

  /**
   * Render import progress section.
   */
  private renderImportProgressSection(): string {
    const transactions = this.batchStats.total.toLocaleString();
    const elapsedMs = this.importStartedAt ? Date.now() - this.importStartedAt : 0;
    const elapsed = this.formatElapsedTime(elapsedMs);

    const transactionsLine = `â”‚  Transactions:  ${transactions.padEnd(47)} â”‚`;
    const elapsedLine = `â”‚  Time Elapsed:  ${elapsed.padEnd(47)} â”‚`;

    return [transactionsLine, elapsedLine].join('\n');
  }

  /**
   * Render event log footer (last 3 events).
   */
  private renderEventLogSection(): string {
    if (this.eventLog.length === 0) {
      return 'â”‚ (no events yet)                                             â”‚';
    }

    return this.eventLog
      .map((evt) => {
        const time = new Date(evt.timestamp).toLocaleTimeString();
        const msg = `${time}  ${evt.icon}  ${evt.message}`;
        return `â”‚ ${msg.padEnd(59).substring(0, 59)} â”‚`;
      })
      .join('\n');
  }

  /**
   * Format elapsed time as mm:ss.
   */
  private formatElapsedTime(ms: number): string {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
  }
}

/**
 * Event log entry for dashboard footer.
 */
export interface EventLogEntry {
  timestamp: number;
  icon: string;
  message: string;
}
